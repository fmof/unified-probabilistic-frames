/*
 * Copyright 2012-2015 Johns Hopkins University HLTCOE. All rights reserved.
 * This software is released under the 2-clause BSD license.
 * See LICENSE in the project root directory.
 */

namespace java edu.jhu.hlt.concrete
namespace py concrete.communication
namespace cpp concrete
#@namespace scala edu.jhu.hlt.miser

include "uuid.thrift"
include "language.thrift"
include "structure.thrift"
include "entities.thrift"
include "situations.thrift"
include "audio.thrift"
include "metadata.thrift"
include "cluster.thrift"

/**
 * A structure that represents a 'tagging' of a Communication. These
 * might be labels or annotations on a particular communcation.
 *
 * For example, this structure might be used to describe the topics
 * discussed in a Communication. The taggingType might be 'topic', and
 * the tagList might include 'politics' and 'science'.
 */
struct CommunicationTagging {
  /**
   * A unique identifier for this CommunicationTagging object.
   */
  1: required uuid.UUID uuid

  /**
   * AnnotationMetadata to support this CommunicationTagging object.
   */
  2: required metadata.AnnotationMetadata metadata

  /**
   * A string that captures the type of this CommunicationTagging
   * object. For example: 'topic' or 'gender'.
   */
  3: required string taggingType

  /**
   * A list of strings that represent different tags related to the taggingType.
   * For example, if the taggingType is 'topic', some example tags might be
   * 'politics', 'science', etc.
   */
  4: optional list<string> tagList

  /**
   * A list of doubles, parallel to the list of strings in tagList,
   * that indicate the confidences of each tag.
   */
  5: optional list<double> confidenceList
}

/** 
 * A single communication instance, containing linguistic content
 * generated by a single speaker or author.  This type is used for
 * both inter-personal communications (such as phone calls or
 * conversations) and third-party communications (such as news
 * articles).
 *
 * Each communication instance is grounded by its original
 * (unannotated) contents, which should be stored in either the
 * "text" field (for text communications) or the "audio" field (for
 * audio communications).  If the communication is not available in
 * its original form, then these fields should store the
 * communication in the least-processed form available.
 */
struct Communication {
  /** 
   * Stable identifier for this communication, identifying both the
   * name of the source corpus and the document that it corresponds to
   * in that corpus. 
   */
  1: required string id

  /**
   * Universally unique identifier for this communication instance.
   * This is generated randomly, and can *not* be mapped back to the
   * source corpus. It is used as a target for symbolic "pointers".
   */
  2: required uuid.UUID uuid

  /** 
   * A short, corpus-specific term characterizing the nature of the
   * communication; may change in a future version of concrete.
   * Often used for filtering.  For example, Gigaword uses
   * the type "story" to distinguish typical news articles from
   * weekly summaries ("multi"), editorial advisories ("advis"), etc.
   * At present, this value is typically a literal form from the
   * originating corpus: as a result, a type marked 'other' may have
   * different meanings across different corpora.
   */
  3: required string type

  /** 
   * The full text contents of this communication in its original
   * form, or in the least-processed form available, if the original
   * is not available. 
   */
  4: optional string text

  /** 
   * The time when this communication started (in unix time UTC --
   * i.e., seconds since January 1, 1970).  
   */
  5: optional i64 startTime

  /** 
   * The time when this communication ended (in unix time UTC --
   * i.e., seconds since January 1, 1970). 
   */
  6: optional i64 endTime

  /**
   * A list of CommunicationTagging objects that can support this
   * Communication. CommunicationTagging objects can be used to
   * annotate Communications with topics, gender identification, etc.
   */
  7: optional list<CommunicationTagging> communicationTaggingList

  /**
   * metadata.AnnotationMetadata to support this particular communication. 
   * 
   * Communications derived from other communications should
   * indicate in this metadata object their dependency
   * to the original communication ID.
   */ 
  8: required metadata.AnnotationMetadata metadata

  /**
   * A catch-all store of keys and values. Use sparingly!
   */
  9: optional map<string, string> keyValueMap

  /** 
   * Theories about the languages that are present in this
   * communication. 
   */
  10: optional list<language.LanguageIdentification> lidList

  
  /**
   * Theory about the block structure of this communication.
   */
  11: optional list<structure.Section> sectionList

  /** 
   * Theories about which spans of text are used to mention entities
   * in this communication. 
   */
  12: optional list<entities.EntityMentionSet> entityMentionSetList

  /** 
   * Theories about what entities are discussed in this
   * communication, with pointers to individual mentions. 
   */
  13: optional list<entities.EntitySet> entitySetList

  /** 
   * Theories about what situations are explicitly mentioned in this
   * communication. 
   */
  14: optional list<situations.SituationMentionSet> situationMentionSetList

  /** 
   * Theories about what situations are asserted in this
   * communication. 
   */
  15: optional list<situations.SituationSet> situationSetList

  /**
   * Optional original text field that points back to an original 
   * communication.
   * 
   * This field can be populated for sake of convenience when creating
   * "perspective" communication (communications that are based on
   * highly destructive changes to an original communication [e.g.,
   * via MT]). This allows developers to quickly access the original
   * text that this perspective communication is based off of.
   */
  16: optional string originalText

  /** 
   * The full audio contents of this communication in its original
   * form, or in the least-processed form available, if the original
   * is not available. 
   */
  20: optional audio.Sound sound

  /**
   * Metadata about this specific Communication, such as information
   * about its author, information specific to this Communication
   * or Communications like it (info from an API, for example), etc. 
   */
  21: optional metadata.CommunicationMetadata communicationMetadata
}

/**
 * A structure that represents a collection of Communications. 
 */
struct CommunicationSet {
  /**
   * A list of Communication UUIDs that this CommunicationSet
   * represents.
   *
   * This field may be absent if this CommunicationSet represents
   * a large corpus. If absent, 'corpus' field should be present.
   */
  1: optional list<uuid.UUID> communicationIdList
  
  /**
   * The name of a corpus or other document body that this
   * CommunicationSet represents.
   *
   * Should be present if 'communicationIdList' is absent. 
   */ 
  2: optional string corpus

  /**
   * A list of Clustering objects that represent a
   * group of EntityMentions that are a part of this
   * CommunicationSet.
   */ 
  3: optional list<cluster.Clustering> entityMentionClusterList

  /**
   * A list of Clustering objects that represent a
   * group of Entities that are a part of this
   * CommunicationSet.
   */ 
  4: optional list<cluster.Clustering> entityClusterList

  /**
   * A list of Clustering objects that represent a
   * group of SituationMentions that are a part of this
   * CommunicationSet.
   */ 
  5: optional list<cluster.Clustering> situationMentionClusterList

  /**
   * A list of Clustering objects that represent a
   * group of Situations that are a part of this
   * CommunicationSet.
   */ 
  6: optional list<cluster.Clustering> situationClusterList
}
